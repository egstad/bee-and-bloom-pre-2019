{"dependencies":[{"name":"properjs-imageloader","loc":{"line":10,"column":24}},{"name":"fg-loadcss","loc":{"line":11,"column":20}},{"name":"fg-loadjs","loc":{"line":12,"column":19}},{"name":"./dom","loc":{"line":13,"column":16}},{"name":"./config","loc":{"line":14,"column":19}},{"name":"./detect","loc":{"line":15,"column":19}},{"name":"./emitter","loc":{"line":16,"column":20}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _properjsImageloader = require(\"properjs-imageloader\");\n\nvar _properjsImageloader2 = _interopRequireDefault(_properjsImageloader);\n\nvar _fgLoadcss = require(\"fg-loadcss\");\n\nvar _fgLoadcss2 = _interopRequireDefault(_fgLoadcss);\n\nvar _fgLoadjs = require(\"fg-loadjs\");\n\nvar _fgLoadjs2 = _interopRequireDefault(_fgLoadjs);\n\nvar _dom = require(\"./dom\");\n\nvar _dom2 = _interopRequireDefault(_dom);\n\nvar _config = require(\"./config\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _detect = require(\"./detect\");\n\nvar _detect2 = _interopRequireDefault(_detect);\n\nvar _emitter = require(\"./emitter\");\n\nvar _emitter2 = _interopRequireDefault(_emitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n *\n * @description Add pixel units when inline styling\n * @method px\n * @param {string} str The value to pixel-ify\n * @memberof core.util\n * @returns {string}\n *\n */\nconst px = function (str) {\n  return `${str}px`;\n};\n\n/**\n *\n * @description Apply a translate3d transform\n * @method translate3d\n * @param {object} el The element to transform\n * @param {string|number} x The x value\n * @param {string|number} y The y value\n * @param {string|number} z The z value\n * @memberof core.util\n *\n */\n/**\n *\n * @public\n * @namespace util\n * @memberof core\n * @description Houses app-wide utility methods.\n *\n */\n// import $ from \"js_libs/jquery/dist/jquery.js\";\nconst translate3d = function (el, x, y, z) {\n  el.style[_detect2.default.getPrefixed(\"transform\")] = `translate3d( ${x}, ${y}, ${z} )`;\n};\n\n/**\n *\n * @description Look-ahead method for pre-loading elements\n * @method isElementLoadable\n * @param {object} el The DOMElement to check the offset of\n * @memberof core.util\n * @returns {boolean}\n *\n */\nconst isElementLoadable = function (el) {\n  if (el) {\n    const bounds = el.getBoundingClientRect();\n\n    return bounds.top < window.innerHeight * 2;\n  }\n};\n\n/**\n *\n * @description Look at elements in the current viewport, vertically\n * @method isElementVisibleVert\n * @param {object} el The DOMElement to check the offsets of\n * @memberof core.util\n * @returns {boolean}\n *\n */\nconst isElementVisibleVert = function (el) {\n  if (el) {\n    const bounds = el.getBoundingClientRect();\n\n    return bounds.top < window.innerHeight && bounds.bottom > 0;\n  }\n};\n\n/**\n *\n * @description Look at elements in the current viewport, horizontally\n * @method isElementVisibleHorz\n * @param {object} el The DOMElement to check the offsets of\n * @memberof core.util\n * @returns {boolean}\n *\n */\nconst isElementVisibleHorz = function (el) {\n  if (el) {\n    const bounds = el.getBoundingClientRect();\n\n    return bounds.left < window.innerWidth && bounds.right > 0;\n  }\n};\n\n/**\n *\n * @method getElementsInView\n * @memberof core.util\n * @param {Hobo} $nodes The collection to process\n * @param {function} executor Optional method to determin `in view`\n * @description Get elements within a loadable position on the page\n * @returns {Hobo}\n *\n */\nconst getElementsInView = function ($nodes, executor) {\n  let i = $nodes.length;\n  const ret = [];\n\n  executor = executor || isElementLoadable;\n\n  for (i; i--;) {\n    if (executor($nodes[i])) {\n      ret.push($nodes[i]);\n    }\n  }\n\n  return $(ret);\n};\n\n/**\n *\n * @description Fresh query to lazyload images on page\n * @method loadImages\n * @param {object} images Optional collection of images to load\n * @param {function} handler Optional handler for load conditions\n * @memberof core.util\n * @returns {ImageLoader}\n *\n */\nconst loadImages = function (images, handler) {\n  // Normalize the handler\n  handler = handler || isElementLoadable;\n\n  // Normalize the images\n  images = images || $(_config2.default.lazyImageSelector);\n\n  // Hook here to determine image variant sizes to load ?\n  _emitter2.default.fire(\"app--util--load-images\", images);\n\n  return new _properjsImageloader2.default({\n    elements: images,\n    property: _config2.default.lazyImageAttr,\n    transitionDelay: 0\n\n  }).on(\"data\", handler);\n};\n\n/**\n *\n * @description Load all deps for a module\n * @method loadDependencies\n * @param {object} data The dependency data\n * @param {function} callback Function to call when all deps are loaded\n * @memberof core.util\n *\n */\nconst loadDependencies = function (data, callback) {\n  let i = 0;\n  const total = data.sources.length;\n  const onload = function () {\n    i++;\n\n    if (i === total) {\n      if (typeof data.callback === \"function\") {\n        data.callback();\n      }\n\n      if (typeof callback === \"function\") {\n        callback();\n      }\n    }\n  };\n\n  data.sources.forEach(source => {\n    if (source.type === \"script\") {\n      (0, _fgLoadjs2.default)(_config2.default.asyncScriptPath + source.file, onload);\n    } else if (source.type === \"style\") {\n      (0, _fgLoadcss2.default)(_config2.default.asyncStylePath + source.file).onloadcssdefined(onload);\n    }\n  });\n};\n\n/**\n *\n * @description Toggle on/off scrollability\n * @method disableMouseWheel\n * @param {boolean} enable Flag to enable/disable\n * @memberof core.util\n *\n */\nconst disableMouseWheel = function (enable) {\n  if (enable) {\n    _dom2.default.doc.on(\"DOMMouseScroll mousewheel\", preNoop);\n  } else {\n    _dom2.default.doc.off(\"DOMMouseScroll mousewheel\");\n  }\n};\n\n/**\n *\n * @description Toggle on/off touch movement\n * @method disableTouchMove\n * @param {boolean} enable Flag to enable/disable\n * @memberof core.util\n *\n */\nconst disableTouchMove = function (enable) {\n  if (enable) {\n    _dom2.default.doc.on(\"touchmove\", preNoop);\n  } else {\n    _dom2.default.doc.off(\"touchmove\");\n  }\n};\n\n/**\n *\n * @description Get the applied transition duration from CSS\n * @method getTransitionDuration\n * @param {object} el The DOMElement\n * @memberof core.util\n * @returns {number}\n *\n */\nconst getTransitionDuration = function (el) {\n  let ret = 0;\n  let duration = null;\n  let isSeconds = false;\n  let multiplyBy = 1000;\n\n  if (el) {\n    duration = getComputedStyle(el)[\"transition-duration\"];\n    isSeconds = String(duration).indexOf(\"ms\") === -1;\n    multiplyBy = isSeconds ? 1000 : 1;\n\n    ret = parseFloat(duration) * multiplyBy;\n  }\n\n  return ret;\n};\n\n/**\n *\n * @description All true all the time\n * @method noop\n * @memberof core.util\n * @returns {boolean}\n *\n */\nconst noop = function () {\n  return true;\n};\n\n/**\n *\n * @description Noop a preventDefault() for event handlers\n * @method preNoop\n * @memberof core.util\n * @param {object} e The event object\n * @returns {boolean}\n *\n */\nconst preNoop = function (e) {\n  e.preventDefault();\n  return false;\n};\n\n/**\n *\n * @description Randomize array element order in-place.\n * Using Fisher-Yates shuffle algorithm.\n * @method shuffle\n * @param {object} arr The array to shuffle\n * @memberof core.util\n * @returns {array}\n *\n */\nconst shuffle = function (arr) {\n  let i = arr.length - 1;\n  let j = 0;\n  let temp = arr[i];\n\n  for (i; i > 0; i--) {\n    j = Math.floor(Math.random() * (i + 1));\n    temp = arr[i];\n\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  return arr;\n};\n\n/**\n *\n * @method calculateAspectRatioFit\n * @memberof core.util\n * @param {number} srcWidth The node width\n * @param {number} srcHeight The node height\n * @param {number} maxWidth The bounds width\n * @param {number} maxHeight The bounds height\n * @description Get optimum size for the given bounds and node dimensions\n * @returns {object}\n *\n */\nconst calculateAspectRatioFit = function (srcWidth, srcHeight, maxWidth, maxHeight) {\n  const ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight);\n\n  return {\n    width: srcWidth * ratio,\n    height: srcHeight * ratio\n  };\n};\n\n/**\n *\n * @public\n * @method getPageKey\n * @memberof util\n * @description Determine the key for local page cache storage.\n * @returns {string}\n *\n */\nconst getPageKey = function () {\n  return `${window.location.pathname}${window.location.search}`;\n};\n\n/**\n *\n * @public\n * @method extendObject\n * @memberof util\n * @param {object} target The target object/array\n * @param {object} arrow The incoming object/array\n * @description Merge or clone objects and arrays\n * @returns {object}\n *\n */\nconst extendObject = function (target, arrow) {\n  let i = null;\n  const ret = target;\n\n  // Merge Arrays\n  // This is really just used as a `cloning` mechanism\n  if (Array.isArray(arrow)) {\n    i = arrow.length;\n\n    for (i; i--;) {\n      ret[i] = arrow[i];\n    }\n\n    // Merge Objects\n    // This could `clone` as well, but is better for merging 2 objects\n  } else {\n    for (i in arrow) {\n      if (arrow.hasOwnProperty(i)) {\n        ret[i] = arrow[i];\n      }\n    }\n  }\n\n  return ret;\n};\n\n/******************************************************************************\n * Export\n*******************************************************************************/\nexports.default = {\n  // Loading\n  loadImages,\n  loadDependencies,\n  getElementsInView,\n  isElementLoadable,\n  isElementVisibleVert,\n  isElementVisibleHorz,\n\n  // Disabling\n  disableTouchMove,\n  disableMouseWheel,\n\n  // Random\n  px,\n  noop,\n  shuffle,\n  getPageKey,\n  translate3d,\n  extendObject,\n  getTransitionDuration,\n  calculateAspectRatioFit\n};"},"hash":"da38f5ee58c81b534781bbad0d8b8671"}