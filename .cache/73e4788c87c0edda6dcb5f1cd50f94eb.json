{"dependencies":[{"name":"properjs-easing","loc":{"line":29,"column":26}},{"name":"properjs-tween","loc":{"line":30,"column":25}}],"generated":{"js":"/*!\n *\n * A lightweight manager for HTML5 audio and video.\n *\n * @MediaBox\n * @singleton\n * @author: kitajchuk\n *\n * @useful web pages with information on this stuffs\n * https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events\n * https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement\n * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video\n * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio\n * https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement\n *\n */\n(function ( factory ) {\n    \n    if ( typeof exports === \"object\" && typeof module !== \"undefined\" ) {\n        module.exports = factory();\n\n    } else if ( typeof window !== \"undefined\" ) {\n        window.MediaBox = factory();\n    }\n    \n})(function () {\n\n\n    var Easing = require( \"properjs-easing\" ),\n        Tween = require( \"properjs-tween\" ),\n        raf = window.requestAnimationFrame,\n        caf = window.cancelAnimationFrame,\n\n    /******************************************************************************\n     * @Private API\n    *******************************************************************************/\n    \n    /**\n     *\n     * Expression match hashbang/querystring\n     * @member rHashQuery\n     * @private\n     *\n     */\n    rHashQuery = /[#|?].*$/g,\n    \n    \n    /**\n     *\n     * Replace \"no\" in canPlayType strings\n     * @member rNos\n     * @private\n     *\n     */\n    rNos = /^no$/,\n    \n    \n    /**\n     *\n     * Clean up all those typeof's\n     * @method isFunction\n     * @returns boolean\n     * @private\n     *\n     */\n    isFunction = function ( fn ) {\n        return (typeof fn === \"function\");\n    },\n    \n    \n    /**\n     *\n     * Test that an object is an Element\n     * @method isElement\n     * @returns boolean\n     * @private\n     *\n     */\n    isElement = function ( el ) {\n        return (el instanceof HTMLElement);\n    },\n    \n    \n    /**\n     *\n     * Borrowed(ish)\n     * Modernizr v3.0.0-alpha.4 on master branch\n     * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/audio.js\n     * @method getAudioSupport\n     * @returns object\n     * @private\n     *\n     */\n    getAudioSupport = function () {\n        var elem = document.createElement( \"audio\" ),\n            ret = {};\n    \n        try {\n            if ( elem.canPlayType ) {\n                ret.ogg = elem.canPlayType( 'audio/ogg; codecs=\"vorbis\"' ).replace( rNos, \"\" );\n                ret.mp3 = elem.canPlayType( 'audio/mpeg;' ).replace( rNos, \"\" );\n                ret.opus = elem.canPlayType( 'audio/ogg; codecs=\"opus\"' ).replace( rNos, \"\" );\n    \n                // Mimetypes accepted:\n                // developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements\n                // bit.ly/iphoneoscodecs\n                ret.wav = elem.canPlayType( 'audio/wav; codecs=\"1\"' ).replace( rNos, \"\" );\n                ret.m4a = (elem.canPlayType( 'audio/x-m4a;' ) || elem.canPlayType( 'audio/aac;' )).replace( rNos, \"\" );\n            }\n    \n        } catch ( e ) {}\n    \n        return ret;\n    },\n    \n    \n    /**\n     *\n     * Borrowed(ish)\n     * Modernizr v3.0.0-alpha.4 on master branch\n     * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/video.js\n     * @method getVideoSupport\n     * @returns object\n     * @private\n     *\n     */\n    getVideoSupport = function () {\n        var elem = document.createElement( \"video\" ),\n            ret = {};\n    \n        try {\n            if ( elem.canPlayType ) {\n                ret.ogg = elem.canPlayType( 'video/ogg; codecs=\"theora\"' ).replace( rNos, \"\" );\n    \n                // Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546\n                ret.h264 = elem.canPlayType( 'video/mp4; codecs=\"avc1.42E01E\"' ).replace( rNos, \"\" );\n                ret.webm = elem.canPlayType( 'video/webm; codecs=\"vp8, vorbis\"' ).replace( rNos, \"\" );\n                ret.vp9 = elem.canPlayType( 'video/webm; codecs=\"vp9\"' ).replace( rNos, \"\" );\n                ret.hls = elem.canPlayType( 'application/x-mpegURL; codecs=\"avc1.42E01E\"' ).replace( rNos, \"\" );\n            }\n    \n        } catch ( e ) {}\n    \n        return ret;\n    },\n    \n    \n    /**\n     *\n     * Get mimetype string from media source\n     * @method getMimeForMedia\n     * @param {string} src media file source\n     * @private\n     *\n     */\n    getMimeForMedia = function ( type, src ) {\n        var ext = src.split( \".\" ).pop().toLowerCase().replace( rHashQuery, \"\" ),\n            ret;\n    \n        if ( type === \"video\" ) {\n            switch ( ext ) {\n                case \"webm\":\n                    ret = \"video/webm\";\n                    break;\n                case \"mp4\":\n                case \"m4v\":\n                    ret = \"video/mp4\";\n                    break;\n                case \"ogv\":\n                    ret = \"video/ogg\";\n                    break;\n            }\n    \n        } else {\n            switch ( ext ) {\n                case \"aac\":\n                    ret = \"audio/aac\";\n                    break;\n                case \"m4a\":\n                    ret = \"audio/x-m4a\";\n                    break;\n                case \"mp4\":\n                    ret = \"audio/mp4\";\n                    break;\n                case \"mp1\":\n                case \"mp2\":\n                case \"mp3\":\n                case \"mpg\":\n                case \"mpeg\":\n                    ret = \"audio/mpeg\";\n                    break;\n                case \"oga\":\n                case \"ogg\":\n                    ret = \"audio/ogg\";\n                    break;\n                case \"wav\":\n                    ret = \"audio/wav\";\n                    break;\n            }\n        }\n    \n        return ret;\n    },\n    \n    \n    /**\n     *\n     * Get the audio source that should be used\n     * @method getCanPlaySource\n     * @param {string} media the media type to check\n     * @param {array} sources Array of media sources\n     * @returns object\n     * @private\n     *\n     */\n    getCanPlaySource = function ( media, sources ) {\n        var source, canPlay;\n    \n        for ( var i = 0, len = sources.length; i < len; i++ ) {\n            var src = sources[ i ].split( \".\" ).pop().toLowerCase().replace( rHashQuery, \"\" );\n    \n    \n            // The only time we break, this honors webm > mp4\n            if ( src === \"webm\" && MediaBox.support[ media ][ src ] === \"probably\" ) {\n                source = sources[ i ];\n                canPlay = MediaBox.support[ media ][ src ];\n                break;\n            }\n    \n            if ( MediaBox.support[ media ][ src ] === \"probably\" || MediaBox.support[ media ][ src ] === \"maybe\" ) {\n                source = sources[ i ];\n                canPlay = MediaBox.support[ media ][ src ];\n            }\n    \n            if ( (src === \"ogv\" || src === \"oga\") && (MediaBox.support[ media ].ogg === \"probably\" || MediaBox.support[ media ].ogg === \"maybe\") ) {\n                source = sources[ i ];\n                canPlay = MediaBox.support[ media ].ogg;\n            }\n    \n            if ( (src === \"mp4\" || src === \"m4v\") && (MediaBox.support[ media ].h264 === \"probably\" || MediaBox.support[ media ].h264 === \"maybe\") ) {\n                source = sources[ i ];\n                canPlay = MediaBox.support[ media ].h264;\n            }\n    \n            if ( src === \"aac\" && (MediaBox.support[ media ].m4a === \"probably\" || MediaBox.support[ media ].m4a === \"maybe\") ) {\n                source = sources[ i ];\n                canPlay = MediaBox.support[ media ].m4a;\n            }\n    \n            if ( (src === \"mp1\" || src === \"mp2\" || src === \"mpg\" || src === \"mpeg\") && (MediaBox.support[ media ].mp3 === \"probably\" || MediaBox.support[ media ].mp3 === \"maybe\") ) {\n                source = sources[ i ];\n                canPlay = MediaBox.support[ media ].mp3;\n            }\n    \n/*\n            if ( source ) {\n                break;\n            }\n*/\n        }\n    \n        return {\n            source: source,\n            canPlay: canPlay\n        };\n    },\n    \n    \n    /**\n     *\n     * MediaBox clear a timeupdate interval for audio/video tracks\n     * @method clearPlaybackUpdate\n     * @param {object} track The media object\n     *\n     */\n    clearPlaybackUpdate = function ( track ) {\n        if ( track._updateId ) {\n            caf( track._updateId );\n    \n            track._updateId = null;\n            track._updateFn = null;\n        }\n    },\n    \n    \n    /**\n     *\n     * MediaBox crossbrowser create audio context\n     * @method createAudioContext\n     * @returns instance of audio context\n     *\n     */\n    createAudioContext = function () {\n        var AudioContext;\n    \n        if ( window.AudioContext ) {\n            AudioContext = window.AudioContext;\n    \n        } else if ( window.webkitAudioContext ) {\n            AudioContext = window.webkitAudioContext;\n        }\n    \n        return ( AudioContext ) ? new AudioContext() : AudioContext;\n    },\n    \n    \n    /**\n     *\n     * MediaBox Open a new XMLHttpRequest\n     * @method createRequest\n     * @returns instance of audio context\n     *\n     */\n    createRequest = function ( url, config, callback ) {\n        var xhr = new XMLHttpRequest();\n    \n        xhr.open( \"GET\", url, true );\n    \n        if ( config ) {\n            for ( var i in config ) {\n                xhr[ i ] = config[ i ];\n            }\n        }\n    \n        xhr.onreadystatechange = function ( e ) {\n            if ( this.readyState === 4 ) {\n                if ( this.status === 200 ) {\n                    try {\n                        if ( !config.responseType ) {\n                            this.responseJSON = JSON.parse( this.responseText );\n                        }\n    \n                        if ( isFunction( callback ) ) {\n                            callback( this );\n                        }\n    \n                    } catch ( error ) {\n                        throw new Error([\n                            error.name,\n                            error.message\n    \n                        ].join( \" : \" ));\n                    }\n                }\n            }\n        };\n    \n        xhr.send();\n    \n        return xhr;\n    },\n    \n    \n    /**\n     *\n     * MediaBox init constructor for singleton\n     * @method init\n     * @private\n     *\n     */\n    init = function () {\n        _instance = this;\n    },\n    \n    \n    /**\n     *\n     * MediaBox default volume setting\n     * @member _volume\n     * @private\n     *\n     */\n    _volume = 1,\n    \n    \n    /**\n     *\n     * MediaBox information for each channel.\n     * These are default channels you can use.\n     * <ul>\n     * <li>bgm - background music channel</li>\n     * <li>sfx - sound effects channel</li>\n     * <li>vid - video channel</li>\n     * </ul>\n     * @member _channels\n     * @private\n     *\n     */\n    _channels = {\n        bgm: {\n            volume: _volume,\n            _builtIn: true\n        },\n        sfx: {\n            volume: _volume,\n            _builtIn: true\n        },\n        vid: {\n            volume: _volume,\n            _builtIn: true\n        }\n    },\n    \n    /**\n     *\n     * MediaBox holds all audio tracks\n     * @member _audio\n     * @private\n     *\n     */\n    _audio = {},\n    \n    /**\n     *\n     * MediaBox holds all video tracks\n     * @member _video\n     * @private\n     *\n     */\n    _video = {},\n    \n    \n    /**\n     *\n     * The singleton instance for MediaBox\n     * @member _instance\n     * @private\n     *\n     */\n    _instance = null,\n    \n    \n    /**\n     *\n     * Master audio context instance\n     * @member _context\n     * @private\n     *\n     */\n    _context = createAudioContext(),\n    \n    \n    /******************************************************************************\n     * @Public API\n    *******************************************************************************/\n    \n    /**\n     *\n     * A complete management tool for html5 video and audio context\n     * @constructor MediaBox\n     * @requires Tween\n     * @memberof! <global>\n     *\n     */\n    MediaBox = function () {\n        return (_instance || init.apply( this, arguments ));\n    };\n    \n    \n    /**\n     *\n     * MediaBox types object\n     * @memberof MediaBox\n     * @member types\n     *\n     */\n    MediaBox.types = {\n        AUDIO: \"audio\",\n        VIDEO: \"video\"\n    };\n    \n    \n    /**\n     *\n     * MediaBox support object\n     * @memberof MediaBox\n     * @member support\n     *\n     */\n    MediaBox.support = {\n        audio: getAudioSupport(),\n        video: getVideoSupport()\n    };\n    \n    \n    /**\n     *\n     * MediaBox stopped state constant\n     * @memberof MediaBox\n     * @member STATE_STOPPED\n     *\n     */\n    MediaBox.STATE_STOPPED = 0;\n    \n    \n    /**\n     *\n     * MediaBox stopping state constant\n     * @memberof MediaBox\n     * @member STATE_STOPPING\n     *\n     */\n    MediaBox.STATE_STOPPING = 1;\n    \n    \n    /**\n     *\n     * MediaBox paused state constant\n     * @memberof MediaBox\n     * @member STATE_PAUSED\n     *\n     */\n    MediaBox.STATE_PAUSED = 2;\n    \n    \n    /**\n     *\n     * MediaBox playing state constant\n     * @memberof MediaBox\n     * @member STATE_PLAYING\n     *\n     */\n    MediaBox.STATE_PLAYING = 3;\n    \n    \n    /**\n     *\n     * MediaBox prototype\n     *\n     */\n    MediaBox.prototype = {\n        constructor: MediaBox,\n    \n        /**\n         *\n         * MediaBox check if media is loaded via ajax\n         * @memberof MediaBox\n         * @method isLoaded\n         * @param {string} id reference id for media\n         * @returns boolean\n         *\n         */\n        isLoaded: function ( id ) {\n            var obj = this.getMedia( id );\n    \n            return (obj.loaded === true);\n        },\n    \n        /**\n         *\n         * MediaBox check stopped/paused status for audio/video\n         * @memberof MediaBox\n         * @method isStopped\n         * @param {string} id reference id for media\n         * @returns boolean\n         *\n         */\n        isStopped: function ( id ) {\n            var obj = this.getMedia( id );\n    \n            return (obj.state === MediaBox.STATE_STOPPED);\n        },\n    \n        /**\n         *\n         * MediaBox check stopped/paused status for audio/video\n         * @memberof MediaBox\n         * @method isPaused\n         * @param {string} id reference id for media\n         * @returns boolean\n         *\n         */\n        isPaused: function ( id ) {\n            var obj = this.getMedia( id );\n    \n            return (obj.state === MediaBox.STATE_PAUSED);\n        },\n    \n        /**\n         *\n         * MediaBox check playing status for audio/video\n         * @memberof MediaBox\n         * @method isPlaying\n         * @param {string} id reference id for media\n         * @returns boolean\n         *\n         */\n        isPlaying: function ( id ) {\n            var obj = this.getMedia( id );\n    \n            return (obj.state === MediaBox.STATE_PLAYING || obj.state === MediaBox.STATE_STOPPING);\n        },\n    \n        /**\n         *\n         * MediaBox set volume for audio OR video\n         * @memberof MediaBox\n         * @method setVolume\n         * @param {string} id reference id for media\n         * @param {number} volume the volume to set to\n         *\n         */\n        setVolume: function ( id, volume ) {\n            var obj = this.getMedia( id );\n    \n            obj._node.volume = volume;\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox set volume for audio OR video\n         * @memberof MediaBox\n         * @method getVolume\n         * @param {string} id reference id for media\n         * @returns number\n         *\n         */\n        getVolume: function ( id ) {\n            var obj = this.getMedia( id );\n    \n            return obj._node.volume;\n        },\n    \n        /**\n         *\n         * MediaBox get an audio nodes property\n         * @memberof MediaBox\n         * @method getAudioProp\n         * @param {string} id Audio id\n         * @param {string} prop The property to access\n         *\n         */\n        getMediaProp: function ( id, prop ) {\n            var obj = this.getMedia( id );\n    \n            if ( obj ) {\n                return obj._node[ prop ];\n            }\n        },\n    \n        /**\n         *\n         * MediaBox set an audio nodes property/attribute\n         * @memberof MediaBox\n         * @method setAudioProp\n         * @param {string} id Audio id\n         * @param {string} prop The property to set\n         * @param {mixed} value The value to assign\n         *\n         */\n        setMediaProp: function ( id, prop, value ) {\n            var obj = this.getMedia( id );\n    \n            if ( obj ) {\n                obj._node[ prop ] = value;\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox get an audio nodes attribute\n         * @memberof MediaBox\n         * @method getAudioAttr\n         * @param {string} id Audio id\n         * @param {string} prop The property to access\n         *\n         */\n        getMediaAttr: function ( id, prop ) {\n            var obj = this.getMedia( id );\n    \n            if ( obj ) {\n                return obj._node.getAttribute( prop );\n            }\n        },\n    \n        /**\n         *\n         * MediaBox set an audio nodes attribute\n         * @memberof MediaBox\n         * @method setAudioAttr\n         * @param {string} id Audio id\n         * @param {string} prop The property to set\n         * @param {mixed} value The value to assign\n         *\n         */\n        setMediaAttr: function ( id, prop, value ) {\n            var obj = this.getMedia( id );\n    \n            if ( obj ) {\n                obj._node.setAttribute( prop, value );\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox add an audio nodes event listener\n         * @memberof MediaBox\n         * @method addAudioEvent\n         * @param {string} id Audio id to add event for\n         * @param {string} event Event to add\n         * @param {function} callback The event handler to call\n         *\n         */\n        addMediaEvent: function ( id, event, callback ) {\n            var obj = this.getMedia( id );\n    \n            if ( obj ) {\n                // Capture timeupdate to run at 60fps instead\n                if ( event === \"timeupdate\" ) {\n                    obj._events.timeupdate = callback;\n    \n                    return _instance;\n                }\n    \n                obj._events[ event ] = function () {\n                    if ( isFunction( callback ) ) {\n                        callback.apply( this, arguments );\n                    }\n                };\n    \n                obj._node.addEventListener( event, obj._events[ event ], false );\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox remove an audio nodes event listener\n         * @memberof MediaBox\n         * @method removeAudioEvent\n         * @param {string} id Audio id to remove event for\n         * @param {string} event Event to remove\n         *\n         */\n        removeMediaEvent: function ( id, event ) {\n            var obj = this.getMedia( id );\n    \n            if ( obj ) {\n                // Capture timeupdate to run at 60fps instead\n                if ( event === \"timeupdate\" ) {\n                    clearPlaybackUpdate( obj );\n                }\n    \n                obj._node.removeEventListener( event, obj._events[ event ], false );\n    \n                obj._events[ event ] = null;\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox play audio node by id\n         * @memberof MediaBox\n         * @method playAudio\n         * @param {string} id reference id for media\n         *\n         */\n        playMedia: function ( id ) {\n            var obj = this.getMedia( id );\n    \n            if ( obj && this.isLoaded( id ) && (this.isStopped( id ) || this.isPaused( id )) ) {\n                obj._node.volume = _channels[ obj.channel ].volume;\n                obj._node.play();\n                obj.state = MediaBox.STATE_PLAYING;\n    \n                if ( !obj._updateId && isFunction( obj._events.timeupdate ) ) {\n                    obj._updateFn = function () {\n                        obj._events.timeupdate.call( obj._node, null );\n                        \n                        obj._updateId = raf( obj._updateFn );\n                    };\n                    \n                    obj._updateId = raf( obj._updateFn );\n                }\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox stop audio node by id with a paused state\n         * @memberof MediaBox\n         * @method pauseAudio\n         * @param {string} id reference id for media\n         *\n         */\n        pauseMedia: function ( id ) {\n            var obj = this.getMedia( id );\n    \n            if ( obj && this.isLoaded( id ) && this.isPlaying( id ) ) {\n                obj._node.pause();\n                obj.state = MediaBox.STATE_PAUSED;\n    \n                clearPlaybackUpdate( obj );\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox stop audio node by id with a stopped state\n         * @memberof MediaBox\n         * @method stopAudio\n         * @param {string} id reference id for media\n         *\n         */\n        stopMedia: function ( id ) {\n            var obj = this.getMedia( id );\n    \n            if ( obj && this.isLoaded( id ) && this.isPlaying( id ) ) {\n                obj._node.pause();\n                obj.state = MediaBox.STATE_STOPPED;\n    \n                clearPlaybackUpdate( obj );\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox get audio object by id\n         * @memberof getMedia\n         * @method getAudio\n         * @param {string} id reference id for media\n         * @returns object\n         *\n         */\n        getMedia: function ( id ) {\n            return _video[ id ] ? _video[ id ] : _audio[ id ];\n        },\n    \n        /**\n         *\n         * MediaBox get all audio objects\n         * @memberof MediaBox\n         * @method getAudios\n         * @returns object\n         *\n         */\n        getAudios: function () {\n            return _audio;\n        },\n    \n        /**\n         *\n         * MediaBox get all video objects\n         * @memberof MediaBox\n         * @method getVideos\n         * @returns object\n         *\n         */\n        getVideos: function () {\n            return _video;\n        },\n    \n        /**\n         *\n         * MediaBox kill a media object abstractly\n         * @memberof MediaBox\n         * @method destroyMedia\n         * @param {string} id reference id for media\n         *\n         */\n        destroyMedia: function ( id ) {\n            var obj = this.getMedia( id );\n    \n            this.stopMedia( id );\n    \n            if ( obj.type === MediaBox.types.AUDIO ) {\n                delete _audio[ id ];\n    \n            } else {\n                delete _video[ id ];\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox load media config JSON formatted in a json bundle\n         * @memberof MediaBox\n         * @method loadMedia\n         * @param {string} url The url to the JSON config\n         * @param {function} callback The function to fire when done loading\n         *\n         */\n        loadMedia: function ( url, callback ) {\n            var self = this;\n    \n            createRequest( url, null, function ( xhr ) {\n                self.addMedia( xhr.responseJSON );\n    \n                if ( isFunction( callback ) ) {\n                    callback();\n                }\n            });\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox add media from bundle json\n         * @memberof MediaBox\n         * @method addMedia\n         * @param {object} bundle Formatted media bundle JSON\n         *\n         */\n        addMedia: function ( bundle ) {\n            for ( var m in bundle ) {\n                for ( var i = bundle[ m ].length; i--; ) {\n                    // this.addVideo() / this.addAudio()\n                    if ( isFunction( this[ m ] ) ) {\n                        this[ m ]( bundle[ m ][ i ] );\n                    }\n                }\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox add a video element\n         * @memberof MediaBox\n         * @method addVideo\n         * @param {object} obj Formatted media bundle\n         *\n         */\n        addVideo: function ( obj ) {\n            var id = obj.id,\n                src = obj.src,\n                props = {\n                    element: obj.element,\n                    channel: obj.channel\n                };\n    \n            // Disallow overrides / Require id and src props\n            if ( _video[ id ] || !id || !src ) {\n                return _instance;\n            }\n    \n            // Allow new channels to exist\n            if ( !_channels[ props.channel ] ) {\n                _channels[ props.channel ] = {\n                    volume: _volume\n                };\n            }\n    \n            // Create video object\n            _video[ id ] = {};\n            _video[ id ].type = MediaBox.types.VIDEO;\n            _video[ id ].state = MediaBox.STATE_STOPPED;\n            _video[ id ].loaded = true;\n            _video[ id ].channel = props.channel;\n            _video[ id ].sources = src;\n            _video[ id ]._source = getCanPlaySource( MediaBox.types.VIDEO, src );\n            _video[ id ]._events = {};\n            _video[ id ]._updateId = null;\n            _video[ id ]._updateFn = null;\n            _video[ id ]._node = (props.element || document.createElement( \"video\" ));\n            _video[ id ]._nodeSource = document.createElement( \"source\" );\n            _video[ id ]._nodeSource.src = _video[ id ]._source.source;\n            _video[ id ]._nodeSource.type = getMimeForMedia( MediaBox.types.VIDEO, _video[ id ]._source.source );\n            _video[ id ]._node.appendChild( _video[ id ]._nodeSource );\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox add an audio context\n         * @memberof MediaBox\n         * @method addAudio\n         * @param {object} obj Formatted media bundle\n         *\n         */\n        addAudio: function ( obj ) {\n            var id = obj.id,\n                src = obj.src,\n                props = {\n                    channel: obj.channel,\n                    CORS: (obj.CORS || false)\n                };\n    \n            // Disallow overrides / Require id and src props\n            if ( _audio[ id ] || !id || !src ) {\n                return _instance;\n            }\n            \n            // Allow new channels to exist\n            if ( !_channels[ props.channel ] ) {\n                _channels[ props.channel ] = {\n                    volume: _volume\n                };\n            }\n    \n            // Create audio object\n            _audio[ id ] = {};\n            _audio[ id ].type = MediaBox.types.AUDIO;\n            _audio[ id ].state = MediaBox.STATE_STOPPED;\n            _audio[ id ].loaded = true;\n            _audio[ id ].channel = props.channel;\n            _audio[ id ].sources = src;\n            _audio[ id ]._source = getCanPlaySource( MediaBox.types.AUDIO, src );\n            _audio[ id ]._events = {};\n            _audio[ id ]._updateId = null;\n            _audio[ id ]._updateFn = null;\n            _audio[ id ]._node = new Audio( _audio[ id ]._source.source );\n    \n            // Get the media as a buffer\n            if ( isFunction( obj.onloaded ) && !props.CORS ) {\n                createRequest( _audio[ id ]._source.source, {responseType: \"arraybuffer\"}, function ( xhr ) {\n                    _context.decodeAudioData( xhr.response, obj.onloaded );\n                });\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox fade in audio/video volume\n         * @memberof MediaBox\n         * @method fadeMediaIn\n         * @param {string} id string reference id for audio\n         * @param {number} duration tween time in ms\n         * @param {function} easing optional easing to use\n         *\n         */\n        fadeMediaIn: function ( id, duration, easing ) {\n            var obj = this.getMedia( id ),\n                self = this,\n                volume;\n    \n            if ( obj && obj.state === MediaBox.STATE_PLAYING ) {\n                return _instance;\n            }\n    \n            if ( obj ) {\n                volume = _channels[ obj.channel ].volume;\n    \n                // Only reset volume and play if object is stopped\n                // Object state could be STATE_STOPPING at this point\n                if ( obj.state === MediaBox.STATE_STOPPED ) {\n                    this.playMedia( id );\n                    this.setVolume( id, 0 );\n    \n                } else if ( obj.state === MediaBox.STATE_STOPPING ) {\n                    obj.state = MediaBox.STATE_PLAYING;\n                }\n    \n                new Tween({\n                    to: volume,\n                    from: 0,\n                    ease: ( isFunction( easing ) ) ? easing : Easing.linear,\n                    duration: (duration || 1000),\n                    update: function ( v ) {\n                        self.setVolume( id, (v > volume) ? volume : v );\n                    },\n                    complete: function () {\n                        self.setVolume( id, volume );\n                    }\n                });\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox fade out audio/video volume\n         * @memberof MediaBox\n         * @method fadeMediaOut\n         * @param {string} id string reference id for audio\n         * @param {number} duration tween time in ms\n         * @param {function} easing optional easing to use\n         *\n         */\n        fadeMediaOut: function ( id, duration, easing ) {\n            var obj = this.getMedia( id );\n    \n            if ( obj && obj.state === MediaBox.STATE_STOPPING ) {\n                return _instance;\n            }\n    \n            var self = this,\n                handler = function ( v ) {\n                    // Check audio state on fadeout in case it is started again\n                    // before the duration of the fadeout is complete.\n                    if ( obj.state === MediaBox.STATE_STOPPING ) {\n                        self.setVolume( id, (v < 0) ? 0 : v );\n    \n                        if ( self.getVolume( id ) === 0 ) {\n                            self.stopMedia( id );\n                        }\n                    }\n                };\n    \n            if ( obj ) {\n                obj.state = MediaBox.STATE_STOPPING;\n    \n                new Tween({\n                    to: 0,\n                    from: self.getVolume( id ),\n                    ease: ( isFunction( easing ) ) ? easing : Easing.linear,\n                    duration: (duration || 1000),\n                    update: handler,\n                    complete: handler\n                });\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox pause all playing audio for a given channel id\n         * @memberof MediaBox\n         * @method stopChannel\n         * @param {string} channel string reference id for channel\n         *\n         */\n        stopChannel: function ( channel ) {\n            var id;\n    \n            // Look at video index\n            for ( id in _video ) {\n                if ( _video[ id ].channel === channel && _video[ id ].state === MediaBox.STATE_PLAYING ) {\n                    this.pauseMedia( id );\n                }\n            }\n    \n            // Look at audio index\n            for ( id in _audio ) {\n                if ( _audio[ id ].channel === channel && _audio[ id ].state === MediaBox.STATE_PLAYING ) {\n                    this.pauseMedia( id );\n                }\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox resume all playing audio for a given channel id\n         * @memberof MediaBox\n         * @method playChannel\n         * @param {string} channel string reference id for channel\n         *\n         */\n        playChannel: function ( channel ) {\n            var id;\n    \n            // Look at video index\n            for ( id in _video ) {\n                if ( _video[ id ].channel === channel && _video[ id ].state === MediaBox.STATE_PAUSED ) {\n                    this.playMedia( id );\n                }\n            }\n    \n            // Look at audio index\n            for ( id in _audio ) {\n                if ( _audio[ id ].channel === channel && _audio[ id ].state === MediaBox.STATE_PAUSED ) {\n                    this.playMedia( id );\n                }\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox fade out all playing audio/video for a given channel id\n         * @memberof MediaBox\n         * @method fadeChannelOut\n         * @param {string} channel string reference id for channel\n         * @param {number} duration tween time in ms\n         *\n         */\n        fadeChannelOut: function ( channel, duration ) {\n            var id;\n    \n            // Look at video index\n            for ( id in _video ) {\n                if ( _video[ id ].channel === channel && _video[ id ].state === MediaBox.STATE_PLAYING ) {\n                    this.fadeMediaOut( id, duration );\n                }\n            }\n    \n            // Look at audio index\n            for ( id in _audio ) {\n                if ( _audio[ id ].channel === channel && _audio[ id ].state === MediaBox.STATE_PLAYING ) {\n                    this.fadeMediaOut( id, duration );\n                }\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox fade in all playing audio/video for a given channel id\n         * @memberof MediaBox\n         * @method fadeChannelIn\n         * @param {string} channel string reference id for channel\n         * @param {number} duration tween time in ms\n         *\n         */\n        fadeChannelIn: function ( channel, duration ) {\n            var id;\n    \n            // Look at video index\n            for ( id in _video ) {\n                if ( _video[ id ].channel === channel && _video[ id ].state === MediaBox.STATE_STOPPED ) {\n                    this.fadeMediaIn( id, duration );\n                }\n            }\n    \n            // Look at audio index\n            for ( id in _audio ) {\n                if ( _audio[ id ].channel === channel && _audio[ id ].state === MediaBox.STATE_STOPPED ) {\n                    this.fadeMediaIn( id, duration );\n                }\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox crossfade volume between multiple channels\n         * @memberof MediaBox\n         * @method crossFadeChannel\n         * @param {string} channel string reference id for channel\n         * @param {string} objId string reference id for object to fade in\n         * @param {number} duration tween time in ms\n         *\n         */\n        crossFadeChannel: function ( channel, objId, duration ) {\n            var id;\n            \n            // Look at video index\n            for ( id in _video ) {\n                if ( _video[ id ].channel === channel && _video[ id ].state === MediaBox.STATE_PLAYING ) {\n                    this.fadeMediaOut( id, duration );\n                }\n            }\n    \n            // Look at audio index\n            for ( id in _audio ) {\n                if ( _audio[ id ].channel === channel && _audio[ id ].state === MediaBox.STATE_PLAYING ) {\n                    this.fadeMediaOut( id, duration );\n                }\n            }\n    \n            return this.fadeMediaIn( objId, duration );\n        },\n    \n        /**\n         *\n         * MediaBox set the property for a channel\n         * @memberof MediaBox\n         * @method setChannelProp\n         * @param {string} id string id reference to channel\n         * @param {string} key string prop key\n         * @param {string} val prop val\n         *\n         */\n        setChannelProp: function ( id, key, val ) {\n            if ( _channels[ id ] ) {\n                _channels[ id ][ key ] = val;\n            }\n    \n            return _instance;\n        },\n    \n        /**\n         *\n         * MediaBox get the property for a channel\n         * @memberof MediaBox\n         * @method getChannelProp\n         * @param {string} id string id reference to channel\n         * @param {string} key string prop key\n         *\n         */\n        getChannelProp: function ( id, key ) {\n            if ( _channels[ id ] ) {\n                return _channels[ id ][ key ];\n            }\n        },\n        \n        \n        /**\n         *\n         * MediaBox get the channels config\n         * @memberof MediaBox\n         * @method _channels\n         *\n         */\n        getChannels: function () {\n            return _channels;\n        }\n    };\n    \n    \n    return MediaBox;\n\n\n});"},"hash":"2d3eecc4721e6d7161db0fd9257c16b2"}