{"dependencies":[{"name":"properjs-pushstate","loc":{"line":20,"column":29}},{"name":"properjs-matchroute","loc":{"line":21,"column":30}},{"name":"properjs-matchelement","loc":{"line":22,"column":32}}],"generated":{"js":"/*!\n *\n * Handles basic get routing\n *\n * @Router\n * @author: kitajchuk\n *\n */\n(function ( factory ) {\n\n    if ( typeof exports === \"object\" && typeof module !== \"undefined\" ) {\n        module.exports = factory();\n\n    } else if ( typeof window !== \"undefined\" ) {\n        window.Router = factory();\n    }\n\n})(function () {\n\n    var PushState = require( \"properjs-pushstate\" ),\n        MatchRoute = require( \"properjs-matchroute\" ),\n        matchElement = require( \"properjs-matchelement\" ),\n        _initDelay = 200,\n        _triggerEl,\n        _activeEl;\n\n\n    /**\n     *\n     * A simple router Class\n     * @constructor Router\n     * @requires PushState\n     * @requires MatchRoute\n     * @requires matchElement\n     * @memberof! <global>\n     *\n     */\n    var Router = function () {\n        return this.init.apply( this, arguments );\n    };\n\n    Router.prototype = {\n        constructor: Router,\n\n        /**\n         *\n         * Expression match http/https\n         * @memberof Router\n         * @member _rHTTPs\n         * @private\n         *\n         */\n        _rHTTPs: /^http[s]?:\\/\\/.*?\\//,\n\n        /**\n         *\n         * Expression match common file types...\n         * @memberof Router\n         * @member _rFiles\n         * @private\n         *\n         */\n        _rFiles: /\\.(jpg|jpeg|png|gif|pdf|csv|txt|md|doc|docx|xls|xlsx|webm|mp4|mp3)$/gi,\n\n        /**\n         *\n         * Expression match this documents domain\n         * @memberof Router\n         * @member _rDomain\n         * @private\n         *\n         */\n        _rDomain: new RegExp( document.domain ),\n\n        /**\n         *\n         * Flag routing state\n         * @memberof Router\n         * @member _isRouting\n         * @private\n         *\n         */\n        _isRouting: false,\n\n        /**\n         *\n         * Router init constructor method\n         * @memberof Router\n         * @method init\n         * @param {object} options Settings for PushState\n         * <ul>\n         * <li>options.caching</li>\n         * <li>options.proxy</li>\n         * <li>options.proxy.domain</li>\n         * <li>options.handle404</li>\n         * <li>options.handle500</li>\n         * <li>options.pushStateOptions</li>\n         * </ul>\n         *\n         * @fires preget\n         * @fires popget\n         * @fires get\n         *\n         */\n        init: function ( options ) {\n            /**\n             *\n             * Router Store user options\n             * @memberof Router\n             * @member _options\n             * @private\n             *\n             */\n            this._options = {\n                async: true,\n                proxy: false,\n                caching: true,\n                handle404: true,\n                handle500: true,\n                pushStateOptions: {}\n            };\n\n            // Normalize usage options passed in\n            options = (options || {});\n\n            // Merge usage options with defaults\n            for ( var i in options ) {\n                this._options[ i ] = options[ i ];\n            }\n\n            /**\n             *\n             * Internal MatchRoute instance\n             * @memberof Router\n             * @member _matcher\n             * @private\n             *\n             */\n            this._matcher = new MatchRoute();\n\n            /**\n             *\n             * Internal PushState instance\n             * @memberof Router\n             * @member _pusher\n             * @private\n             *\n             */\n            this._pusher = new PushState( this._options.pushStateOptions );\n\n            /**\n             *\n             * Event handling callbacks\n             * @memberof Router\n             * @member _callbacks\n             * @private\n             *\n             */\n            this._callbacks = {};\n\n            /**\n             *\n             * Stored XHR responses\n             * @memberof Router\n             * @member _responses\n             * @private\n             *\n             */\n            this._responses = {};\n\n            /**\n             *\n             * Router unique ID\n             * @memberof Router\n             * @member _uid\n             * @private\n             *\n             */\n            this._uid = 0;\n\n            /**\n             *\n             * Router is READY status ?\n             * @memberof Router\n             * @member _ready\n             * @private\n             *\n             */\n            this._ready = false;\n        },\n\n        /**\n         *\n         * Create PushState instance and add event listener\n         * @memberof Router\n         * @method bind\n         *\n         */\n        bind: function () {\n            var self = this,\n                // Ensure this first cache URL is clean as a whistle\n                url = window.location.href.replace( window.location.hash, \"\" );\n\n            // Bind GET requests to links\n            document.addEventListener( \"click\", function ( e ) {\n                self._handleClick( this, e );\n\n            }, false );\n\n            // Bind popstate event for history\n            this._pusher.on( \"popstate\", function ( url, state ) {\n                self._handlePopstate( url, state );\n            });\n\n            // Fire first route\n            // Async this in order to allow .get() to work after instantiation\n            if ( this._options.async && this._options.handle404 ) {\n                this._route( url, function ( response, status ) {\n                    self._ready = true;\n                });\n\n            // Shim a little and bypass true XHR here if not handling 404s\n            } else {\n                setTimeout(function () {\n                    // https://developer.mozilla.org/en-US/docs/Web/API/XMLSerializer\n                    var doc = new XMLSerializer().serializeToString( document );\n                    var xhr = {\n                        status: 200,\n                        responseText: doc\n                    };\n\n                    self._fire( \"get\", url, xhr, xhr.status );\n                    self._cache( url, xhr );\n                    self._ready = true;\n\n                }, _initDelay );\n            }\n        },\n\n        /**\n         *\n         * Add an event listener\n         * Binding \"beforeget\" and \"afterget\" wraps the XHR request\n         * @memberof Router\n         * @method on\n         * @param {string} event The event to bind to\n         * @param {function} callback The function to call\n         *\n         */\n        on: function ( event, callback ) {\n            this._bind( event, callback );\n        },\n\n        /**\n         *\n         * Remove an event listener\n         * @memberof Router\n         * @method off\n         * @param {string} event The event to unbind\n         * @param {function} callback The function to reference\n         *\n         */\n        off: function ( event, callback ) {\n            this._unbind( event, callback );\n        },\n\n        /**\n         *\n         * Support router triggers by url\n         * @memberof Router\n         * @method trigger\n         * @param {string} url The url to route to\n         *\n         */\n        trigger: function ( url ) {\n            if ( !_triggerEl ) {\n                _triggerEl = document.createElement( \"a\" );\n            }\n\n            _triggerEl.href = url;\n\n            this._handleClick( _triggerEl, {\n                target: _triggerEl\n            });\n        },\n\n        /**\n         *\n         * Bind a GET request route\n         * @memberof Router\n         * @method get\n         * @param {string} route route to match\n         * @param {function} callback function to call when route is requested\n         *\n         */\n        get: function ( route, callback ) {\n            // Add route to matcher\n            this._matcher.config( [route] );\n\n            // Bind the route to the callback\n            if ( callback._routerRoutes ) {\n                callback._routerRoutes.push( route );\n\n            } else {\n                callback._routerRoutes = [route];\n            }\n\n            // When binding multiple routes to a single\n            // callback, we need to make sure the callbacks\n            // routes array is updated above but the callback\n            // only gets added to the list once.\n            if ( callback._routerRoutes.length === 1 ) {\n                this._bind( \"get\", callback );\n            }\n        },\n\n        getActiveEl: function () {\n            return _activeEl;\n        },\n\n        /**\n         *\n         * Get a sanitized route for a url\n         * @memberof Router\n         * @method getRouteForUrl\n         * @param {string} url The url to use\n         * @returns {string}\n         *\n         */\n        getRouteForUrl: function ( url ) {\n            return this._matcher._cleanRoute( url );\n        },\n\n        /**\n         *\n         * Get the match data for a url against the routes config\n         * @memberof Router\n         * @method getRouteDataForUrl\n         * @param {string} url The url to use\n         * @returns {object}\n         *\n         */\n        getRouteDataForUrl: function ( url ) {\n            return this._matcher.parse( url, this._matcher.getRoutes() ).params;\n        },\n\n        /**\n         *\n         * Get a unique ID\n         * @memberof Router\n         * @method getUID\n         * @returns number\n         *\n         */\n        getUID: function () {\n            this._uid = (this._uid + 1);\n\n            return this._uid;\n        },\n\n        /**\n         * Compatible event preventDefault\n         * @memberof Router\n         * @method _preventDefault\n         * @param {object} e The event object\n         * @private\n         *\n         */\n        _preventDefault: function ( e ) {\n            if ( e.preventDefault ) {\n                e.preventDefault();\n\n            } else {\n                e.returnValue = false;\n            }\n        },\n\n        /**\n         * GET click event handler\n         * @memberof Router\n         * @method _handleClick\n         * @param {object} el The event context element\n         * @param {object} e The event object\n         * @private\n         *\n         * @fires get\n         *\n         */\n        _handleClick: function ( el, e ) {\n            var elem = (matchElement( el, \"a\", true ) || matchElement( e.target, \"a\", true )),\n                isMatched = elem && this._matcher.test( elem.href ),\n                isDomain = elem && this._rDomain.test( elem.href ),\n                isProxy = elem && this._options.proxy && this._options.proxy.domain,\n                isHashed = elem && elem.href.indexOf( \"#\" ) !== -1,\n                isIgnore = elem && elem.className.indexOf( \"js-router--ignore\" ) !== -1,\n                isMetaKey = elem && e.metaKey,\n                isBlank = elem && elem.target === \"_blank\",\n                isFile = elem && isDomain && elem.href.match( this._rFiles );\n\n            // 0.1 => Ensure url passes MatchRoute config\n            // 0.2 => Ensure url is on the Document's Domain\n            // 0.X => Allow proxy domain's to go through this checkpoint\n            if ( (isMatched && isDomain) || isProxy ) {\n                // 0.3 => Ensure url is not a #hash\n                // 0.4 => Ensure the element does not contain a `js-router--ignore` className\n                // 0.5 => Ensure the Event.metaKey is not TRUE - Command+click\n                // 0.6 => Ensure the element target is not for a new tab\n                // 0.7 => Ensure url is not a file link on the same document domain\n                if ( !isHashed && !isIgnore && !isMetaKey && !isBlank && !isFile ) {\n                    _activeEl = elem;\n\n                    this._preventDefault( e );\n\n                    if ( !this._isRouting ) {\n                        this._route( elem.href );\n                    }\n                }\n            }\n        },\n\n        /**\n         * Handle history popstate event from PushState\n         * @memberof Router\n         * @method _handlePopstate\n         * @param {string} url The url popped to\n         * @param {object} state The PushState state object\n         * @private\n         *\n         * @fires get\n         *\n         */\n        _handlePopstate: function ( url, state ) {\n            // Hook around browsers firing popstate on pageload\n            if ( this._ready ) {\n                for ( var i = this._callbacks.get.length; i--; ) {\n                    var dat = this._matcher.parse( url, this._callbacks.get[ i ]._routerRoutes );\n\n                    if ( dat.matched ) {\n                        break;\n                    }\n                }\n\n                data = {\n                    route: this._matcher._cleanRoute( url ),\n                    response: this._responses[ url ],\n                    request: dat,\n                    status: this._responses[ url ].status\n                };\n\n                this._fire( \"popget\", url, data );\n\n            } else {\n                this._ready = true;\n            }\n        },\n\n        /**\n         * Execute the route\n         * @memberof Router\n         * @method _route\n         * @param {string} url The url in question\n         * @param {function} callback Optional, fired with done\n         * @private\n         *\n         */\n        _route: function ( url, callback ) {\n            var self = this,\n                urls = {\n                    // For XHR\n                    request: url,\n\n                    // For pushState and Cache\n                    original: url\n                };\n\n            this._isRouting = true;\n\n            this._matchUrl( urls.original );\n\n            // Handle proxy first since we modify the request URL\n            // Basically, just piece together a URL that swaps this domain with proxy domain\n            if ( this._options.proxy && this._options.proxy.domain ) {\n                // Use window.location.host so it includes port for localhost\n                urls.request = (this._options.proxy.domain + \"/\" + urls.request.replace( this._rHTTPs, \"\" ));\n            }\n\n            this._getUrl( urls, function ( response, status ) {\n                self._isRouting = false;\n\n                // Push the URL to window History\n                self._pusher.push( urls.original );\n\n                // Fire event for routing\n                self._fire( \"get\", urls.original, response, status );\n\n                if ( typeof callback === \"function\" ) {\n                    callback( response, status );\n                }\n            });\n        },\n\n        /**\n         * Match a URL and fire \"preget\"\n         * @memberof Router\n         * @method _matchUrl\n         * @param {string} url The url in question\n         * @private\n         *\n         */\n        _matchUrl: function ( url ) {\n            if ( !this._ready ) {\n                return;\n            }\n\n            for ( var i = this._callbacks.get.length; i--; ) {\n                var data = this._matcher.parse( url, this._callbacks.get[ i ]._routerRoutes );\n\n                if ( data.matched ) {\n                    this._fire( \"preget\", url, data );\n                    break;\n                }\n            }\n        },\n\n        /**\n         *\n         * Request a url with an XMLHttpRequest\n         * @memberof Router\n         * @method _getUrl\n         * @param {object} urls The urls to request / push / cache\n         * @param {function} callback The function to call when done\n         * @private\n         *\n         */\n        _getUrl: function ( urls, callback ) {\n            var handler = function ( res, stat ) {\n                    try {\n                        // Cache if option enabled\n                        self._cache( urls.original, res );\n\n                        if ( typeof callback === \"function\" ) {\n                            callback( res, stat );\n                        }\n\n                    } catch ( error ) {}\n                },\n                xhr = null,\n                self = this;\n\n            // Cached response ?\n            if ( this._responses[ urls.original ] ) {\n                handler( this._responses[ urls.original ], this._responses[ urls.original ].status );\n\n            // Fresh request ?\n            } else if ( this._options.async ) {\n                xhr = new XMLHttpRequest();\n\n                xhr.open( \"GET\", urls.request, true );\n\n                xhr.onreadystatechange = function ( e ) {\n                    if ( this.readyState === 4 ) {\n                        if ( this.status === 200 ) {\n                            handler( this, 200 );\n\n                        } else if ( this.status === 404 && self._options.handle404 ) {\n                            handler( this, 404 );\n\n                        } else if ( this.status === 500 && self._options.handle500 ) {\n                            handler( this, 500 );\n                        }\n                    }\n                };\n\n                xhr.send();\n\n            } else {\n                handler( { responseText: \"\" }, 200 );\n            }\n        },\n\n        /**\n         *\n         * Cache an XHR response object\n         * @memberof Router\n         * @method _cache\n         * @param {string} url The url to cache for\n         * @param {object} res The XHR object\n         * @private\n         *\n         */\n        _cache: function ( url, res ) {\n            // Caching is enabled, Not currently cached yet\n            if ( this._options.caching && !this._responses[ url ] ) {\n                this._responses[ url ] = res;\n            }\n        },\n\n        /**\n         *\n         * Bind an event to a callback\n         * @memberof Router\n         * @method _bind\n         * @param {string} event what to bind on\n         * @param {function} callback fired on event\n         * @private\n         *\n         */\n        _bind: function ( event, callback ) {\n            if ( typeof callback === \"function\" ) {\n                if ( !this._callbacks[ event ] ) {\n                    this._callbacks[ event ] = [];\n                }\n\n                callback._jsRouterID = this.getUID();\n\n                this._callbacks[ event ].push( callback );\n            }\n        },\n\n        /**\n         *\n         * Unbind an event to a callback(s)\n         * @memberof Router\n         * @method _bind\n         * @param {string} event what to bind on\n         * @param {function} callback fired on event\n         * @private\n         *\n         */\n        _unbind: function ( event, callback ) {\n            if ( !this._callbacks[ event ] ) {\n                return this;\n            }\n\n            // Remove a single callback\n            if ( callback ) {\n                for ( var i = 0, len = this._callbacks[ event ].length; i < len; i++ ) {\n                    if ( callback._jsRouterID === this._callbacks[ event ][ i ]._jsRouterID ) {\n                        this._callbacks[ event ].splice( i, 1 );\n\n                        break;\n                    }\n                }\n\n            // Remove all callbacks for event\n            } else {\n                for ( var j = this._callbacks[ event ].length; j--; ) {\n                    this._callbacks[ event ][ j ] = null;\n                }\n\n                delete this._callbacks[ event ];\n            }\n        },\n\n        /**\n         *\n         * Fire an event to a callback\n         * @memberof Router\n         * @method _fire\n         * @param {string} event what to bind on\n         * @param {string} url fired on event\n         * @param {string} response html from responseText\n         * @param {number} status The request status\n         * @private\n         *\n         */\n        _fire: function ( event, url, response, status ) {\n            var i;\n\n            // GET events have routes and are special ;-P\n            if ( event === \"get\" ) {\n                for ( i = this._callbacks[ event ].length; i--; ) {\n                    var data = this._matcher.parse( url, this._callbacks[ event ][ i ]._routerRoutes );\n\n                    if ( data.matched ) {\n                        this._callbacks[ event ][ i ].call( this, {\n                            route: this._matcher._cleanRoute( url ),\n                            response: response,\n                            request: data,\n                            status: status\n                        });\n                    }\n                }\n\n            // Fires basic timing events \"preget\", \"popget\"\n            } else if ( this._callbacks[ event ] ) {\n                for ( i = this._callbacks[ event ].length; i--; ) {\n                    this._callbacks[ event ][ i ].call( this, response );\n                }\n            }\n        }\n    };\n\n\n    return Router;\n\n});\n"},"hash":"db2ea5e273e78dd3709db6a8a43dfb08"}