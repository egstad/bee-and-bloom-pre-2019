{"dependencies":[],"generated":{"js":"/*!\n *\n * Parse query string into object literal representation\n *\n * @compat: jQuery, Ender, Zepto\n * @author: @kitajchuk\n *\n *\n */\n(function ( factory ) {\n    \n    if ( typeof exports === \"object\" && typeof module !== \"undefined\" ) {\n        module.exports = factory();\n\n    } else if ( typeof window !== \"undefined\" ) {\n        window.paramalama = factory();\n    }\n    \n})(function () {\n    \n    var paramalama = function ( str ) {\n        var query = decodeURIComponent( str ).match( /[#|?].*$/g ),\n            ret = {};\n        \n        if ( query ) {\n            query = query[ 0 ].replace( /^\\?|^#|^\\/|\\/$|\\[|\\]/g, \"\" );\n            query = query.split( \"&\" );\n            \n            for ( var i = query.length; i--; ) {\n                var pair = query[ i ].split( \"=\" ),\n                    key = pair[ 0 ],\n                    val = pair[ 1 ];\n                \n                if ( ret[ key ] ) {\n                    // #2 https://github.com/kitajchuk/paramalama/issues/2\n                    // This supposedly will work as of ECMA-262\n                    // This works since we are not passing objects across frame boundaries\n                    // and we are not considering Array-like objects. This WILL be an Array.\n                    if ( {}.toString.call( ret[ key ] ) !== \"[object Array]\" ) {\n                        ret[ key ] = [ ret[ key ] ];\n                    }\n                    \n                    ret[ key ].push( val );\n                    \n                } else {\n                    ret[ key ] = val;\n                }\n            }\n        }\n        \n        return ret;\n    };\n    \n    if ( typeof $ !== \"undefined\" ) {\n        $.paramalama = paramalama;\n    }\n\n    return paramalama;\n    \n});\n"},"hash":"02aec25461db9dd3503ab9107c724ae1"}